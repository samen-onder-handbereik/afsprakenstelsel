---
title: Technische patronen
author: lg
date: 2025-09-29
category: Jekyll
layout: post
---

CORV
-------------

> ##### Concept
{: .block-danger }

CORV (Collectieve Opdracht Routeer Voorziening) verbindt sinds de decentralisaties rond 2015 de gemeentewereld, zorgwereld en justitiewereld om bilateraal berichten te kunnen uitwisselen. Ketenpartners hebben een aansluiting op de CORV via het gemeente, zorg of justitienet. Het betreft een centrale dienst in het zogenoemde hub-spoke model. De routeervoorziening is de centrale hub waar de spokes, lees de verschillende organisaties zijn aangesloten. Via CORV worden berichten tussen organisaties uitgewisseld op basis van asynchroon berichtenverkeer (ebMS). CORV maakt gebruik van een push-push patroon. Dat betekent dat berichten van de melder naar CORV worden geduwd, waarbij CORV vervolgens de berichten ook duwt naar de ontvanger. CORV kent verschillende aanvullende services, naast routeren, denk bijvoorbeeld aan vertalen en monitoring.

CORV ondersteunt het estafette informatie model goed, maar doet dit vooral op basis van een verouderend protocol (ebMS) en een verouderende methodiek ebMS/WUS berichtenuitwisseling. Die veroudering zorgt (op termijn) voor beperkte ondersteuning door leveranciers, minder makkelijk aan te trekken talent dat kennis van heeft van deze techniek, beperkte ondersteuning voor nieuwe wensen en benodigdheden zoals netwerkmodel ondersteuning en ondersteuning van gebeurtenisgedrevenheid. 

Vandaar dat CORV2 ontwikkelt wordt. CORV2 ondersteunt zowel estafette model als netwerkmodel, zowel ebMS als REST API, zowel berichten als vraag-antwoord (REST API) als gebeurtenissen (events). CORV2 zal op termijn geen ebMS/WUS meer ondersteunen. Die termijn zal naar verwachting echter minimaal een decennium zijn. Vandaar dat CORV2 ook een overbruggingsdienst zal bevatten of deze naast CORV2 gepositioneerd zijn. Deze overbruggingsdienst is ook wel bekend onder de naam Silvester. Deze dienst zal berichten conform estafette model kunnen omzetten naar berichten/events conform netwerkmodel en vice versa. Dus ebMS berichten kunnen omzetten naar REST API berichten of events en andersom.

Via het afsprakenstelsel wordt invulling gegeven aan het netwerkmodel. CORV2 is daarbij een, zei het essentieel, hulpmiddel. 


Gebeurtenissen (events)
-------------

![Alt text]({{ site.baseurl }}/assets/eventshl.png)

> ##### Concept
{: .block-danger }

### Identificeren en uitsturen van gebeurtenissen
Binnen het stelsel willen we gebeurtenissen kunnen delen. Bijvoorbeeld: “Wij Politie hebben zojuist melding xyz gedaan bij Veilig Thuis”. Een eerste vraag is dan hoe we gebeurtenissen kunnen identificeren en uitsturen vanuit de bron, lees het systeem dat de desbetreffende partij gebruikt. Hier zijn grosso modo de volgende mogelijke manieren voor:
1. Het (business/zaak)systeem ondersteunt native het genereren en uitsturen van events.
2. Het (business/zaak)systeem ondersteunt eventcreatie en verzending nog niet, maar dit kan in het systeem worden ingebouwd.
3. Het (business/zaak)systeem ondersteunt eventcreatie en verzending niet, maar met ‘External Event Capture’ functionaliteit kunnen alsnog events worden gegenereerd en uitgestuurd.

Denk bij dit laatste aan het monitoren van applicatie logging (log scraping), database triggers/capture (CDC) of automation hooks (RPA of automation tool). Zodoende kunnen events worden geïdentificeerd, geëxporteerd, onderschept of gesynthetiseerd en vervolgens worden uitgestuurd.


> ##### Concept
{: .block-danger }

### Gebeurtenissen vormgeven en verzenden
Een gebeurtenis wordt vormgeven binnen de CloudEvents standaard en conform het NL GOV profile for CloudEvents. De daadwerkelijke inhoud is afgeleid van het betreffende informatiemodel van de betreffende samenwerkfunctie (zie Samenwerkfuncties). Objecten en attributen volgen waar afgesproken de definities van het Begrippenkader.

De gebeurtenis wordt verzonden naar de CORV2 event broker. Deze biedt hiervoor een REST API aan (REST API Proxy naar Event Platform event-log/topic). De REST API wordt aangeroepen en het event via deze API aangeleverd. De REST API is beschreven in het API Management DevPortal van CORV2.



> ##### Concept
{: .block-danger }

### Gebeurtenissen ontvangen en interpreteren
De organisatie welke gebeurtenissen wil of moet ontvangen, heeft het ontvangen daarvan in eigen hand. De organisatie kan via de betreffende REST API (REST API Proxy naar Event Platform event-log/topic) een ‘pull’ actie uitvoeren en zodoende (relevante) gebeurtenissen ophalen.

Uiteraard is toegang nodig tot deze REST API en de gebeurtenissen. Wat betreft gebeurtenissen zijn hier twee varianten:
1. De betreffende gebeurtenissen zijn voor de gehele keten toegankelijk. Merk op dat de gebeurtenis (het event) weinig informatie bevat en er een inzage verzoek nodig is voor meer informatie.
2. De betreffende gebeurtenissen zijn alleen toegankelijk voor partijen die een toegangsverzoek hebben gedaan, dat is gehonoreerd. Zij ontvangen dan een token waarmee de gebeurtenissen toegankelijk worden. Ook hier zal doorgaans een inzage verzoek nodig zijn voor meer informatie.    

Het genoemde inzage verzoek kent een eigen toegangsverleningsproces (authenticatie/autorisatie).

Interpretatie van gebeurtenissen wordt gefaciliteerd door enerzijds de CloudEvent standaard. De REST API response bevat de in de CloudEvents standaard en conform het NL GOV profile for CloudEvents vormgegeven event. Anderzijds door event informatiemodel. Dit gaat over wat in het Cloud Event wordt geplaatst (welke attributen/headers). Dit is ook wel bekend onder de noemer Schema registry pattern. Een Schema registry levert versioning en backward and forward compatibility. Verder wordt de interpretatie gefaciliteerd door het informatiemodel en daarmee ook door de definitie van objecten en attributen conform het keten Begrippenkader en door de samenwerkfunctie (zie Samenwerkfuncties).



> ##### Concept
{: .block-danger }

### Gebeurtenissen verwerken
Ontvangen en (kunnen) interpreteren is niet voldoende. Gebeurtenissen moeten kunnen worden verwerkt in het (business/zaak)systeem. Hier zijn grosso modo de volgende mogelijke manieren voor:
1. Het (business/zaak)systeem ondersteunt native events subscription en verwerking. Het systeem kan de events verwerken, ‘parsen’ en acties nemen op basis van de inhoud van de events.
2. Het (business/zaak)systeem ondersteunt events subscription en verwerking nog niet, maar dit kan in het systeem worden ingebouwd.
3. Het (business/zaak)systeem ondersteunt eventcreatie en verzending niet, maar met ‘middleware services’ kunnen de events alsnog worden verwerkt en acties uitgezet worden, bijvoorbeeld door transformatie naar systeem API calls, system calls, database mutaties of UI automation acties.

Onderdeel van de verwerking van gebeurtenissen is het analyseren daarvan via bijvoorbeeld business rules of workflow engines. Op basis van de analyse kunnen acties worden uitgezet (binnen het systeem / de applicatie). Dit kan binnen de applicatie zelf of binnen daarvoor bestemde (middleware) services.

### Gebeurtenissen routeren
Binnen het stelsel moeten gebeurtenissen tussen verschillende organisaties uitgewisseld kunnen worden. Technisch bezien zou dat direct kunnen, dus zonder centrale of gedeelde voorzieningen. In praktische zin echter niet gelet onder andere  complexiteit en schaalbaarheid. Er is voor de uitwisseling van gebeurtenissen dus een gedeelde voorziening nodig (CORV2).

De uitwisseling en routering van de gebeurtenissen kan in een publish/subscribe (pub/sub)model. Doorgaans wordt hiervoor gekozen wanneer sprake is van gelijksoortige omgevingen en daardoor ook native pub/sub interfaces gebruikt kunnen worden, of wanneer het aantal organisaties waarmee wordt uitgewisseld beperkt is. In dit geval is van geen van beide sprake. Vandaar dat gekozen wordt voor een benadering in hogere mate loosely coupled is dan pub/sub. Die benadering maakt gebruik van REST API interfaces die voor de logg/stream/topic interfaces geplaatst worden en van het push/pull model (in plaats van pub/sub). Organisaties (event producers) sturen gebeurtenissen via een gedefinieerde standaard REST API naar de Event Hub (CORV2), ontvangende organisaties (consumers) bevragen (pull) de Event Hub op nieuwe berichten.


Bevragingen en opdrachten (REST API)
-------------

![Alt text]({{ site.baseurl }}/assets/apihl.png)

> ##### Concept
{: .block-danger }

### Identificeren en uitsturen van vraag of opdracht
Binnen het stelsel moet informatie opgevraagd kunnen worden of opdrachten uitgezet. Ook kan sprake zijn dat informatie moet worden gewijzigd of verwijderd. Meer technisch geformuleerd zouden we kunnen spreken over CRUD. CRUD staat voor Create, Read, Update en Delete. REST API’s zijn zeer geschikt voor dit type operaties. Op basis van het Keteninformatiemodel, het Begrippenmodel en Samenwerkingsfuncties en Samenwerkpatronen kunnen vragen of opdrachten worden samengesteld in de vorm van REST-API calls.

Als reeds bekend is welke REST-API we nodig hebben kan deze worden aangeroepen. Als dit nog niet het geval is kan deze worden opgezocht door de API Catalog te raadplegen.

De REST API’s calls kunnen direct vanuit het (zaak)systeem/applicatie worden gedaan of kunnen specifieke (micro)services worden ingezet.


> ##### Concept
{: .block-danger }

### Vragen/opdrachten vormgeven en verzenden
De verwerking van de ontvangen response vindt plaats in het (zaak)systeem/applicatie of daaraan gerelateerde specifieke (micro)services.

> ##### Concept
{: .block-danger }

### Vragen/opdrachten verwerken
Aanbieders van de REST-API publiceren deze in hun API DevPortal. Daar is in meer detail na te gaan hoe de API calls vormgegeven dienen te worden, hoe toegang kan worden aangevraagd etc. Verder helpen het Keteninformatiemodel, het Begrippenmodel en Samenwerkingsfuncties en Samenwerkpatronen bij de vormgeving van de calls. Andersom helpen deze ook hoe de REST API’s door de aanbieder ervan gebouwd en aangeboden dienen te worden.


> ##### Concept
{: .block-danger }

### Typen REST-API’s
Enerzijds zullen er wat resources-API’s genoemd worden zijn. Deze volgen de interne / domeinspecifieke resources met overeenkomstige duidelijke, consistente, zelfstandige naamwoorden (nouns) conform de API design rules. Deze zullen doorgaans worden geabstraheerd achter wat we keten-API’s noemen. Die volgen het afgesproken Keteninformatiemodel en het Begrippenkader en daarmee niet noodzakelijkerwijs de achterliggende resource benamingen (binnen het systeem/applicatie en het informatiemodel daarvan). Deze keten-API’s kunnen meerdere achterliggende resources-API’s benaderen om bijvoorbeeld het aantal API call’s te reduceren. De keten-API’s kunnen ook achterliggende business-API’s benaderen. Een business API richt zich op bredere bedrijfsprocessen of business capabilities als resource. In plaats van data-objecten op een lager niveau richt een business API zich op functionele eenheden die een businessdoel dienen. Dat in tegenstelling tot een resource-API welke is gebouwd rondom het concept van resources en daarmee van data entiteiten of objecten die via unieke URI's worden geïdentificeerd.

Bevragingen en opdrachten (REST API)
-------------

> ##### Concept
{: .block-danger }

Binnen de Samenwerkfuncties zal nadrukkelijk ook een combinatie worden gebruikt. Een organisatie kan een notificatie doen (event uitsturen), andere organisaties kunnen op basis van het event een bevraging doen (REST-API).

Deze werkwijze heeft als bijkomstig voordeel dat REST API authenticatie en autorisatie hergebruikt kan worden. Daardoor kan de complexiteit van het  toegangslandschap worden gereduceerd.


Semantisch model
-------------

> ##### Concept
{: .block-danger }

In een keten met veel verschillende partijen en diverse samenwerkfuncties is een gemeenschappelijke taal belangrijk. Er kunnen hier verschillende benaderingen worden gevolgd:
1. De aanbieder bepaalt het model van de eigen aanleveringen en voorziet deze van context en betekenis. Alle afnemers vertalen het model van de aanbieder naar het eigen model en zorgen daarbij dat ze de betekenis en context goed doorgronden. Dit model is ongeschikt voor deze keten gelet het type organisaties, het aantal daarvan en verschillen daartussen. In een andere context kan dit model overigens zeer geschikt zijn.
2. Er wordt onderscheid gemaakt in verschillende domeinen binnen de keten. Elk domein volgt het eigen semantisch model en biedt vanuit daar aan en in lijn daarmee. Alle afnemers vertalen het model van de aanbieder naar het eigen model en zorgen daarbij dat ze de betekenis en context goed doorgronden. Dit model kent dezelfde nadelen als voorgaande model in de geldende context, zij het in een minder zware vorm.
3. Alle partijen volgen het keten Informatiemodel en passen dat toe in keten-API’s en in het keten event datamodel. Deze benadering past goed bij ketens met veel verschillende partijen en in situaties waar nog veel API’s ontwikkelt moeten worden.



> ##### Concept
{: .block-danger }

De werking van CORV2 is in meer detail hieronder uitgebeeld en beschreven.

![Alt text]({{ site.baseurl }}/assets/corv2funct.png)

Stappen:
1. Aanvragen van een autorisatie token voor event-log/topic (alleen voor gesloten topics)
2. Opvragen van het schema
3. Aanleveren van events (push)
4. Opvragen van events (pull)
5. Opvragen van de status

CORV2 componenten:
- **Schema registry** – Opslag van event data schema’s t.b.v. versioning, backward/forward compatibility, validatie en voorkomen van breaking changes
- **REST API Proxy** – Transformatie van event streams naar REST API voor ontkoppeling en abstractie
- **Event broker** – Ontvangen, routeren en doorgeven van events
- **House keeping service** – Opschonen, retentie van event logs/topics
- **Writer services** – Database en Blockchain writers voor (immutable en onweerlegbare) opslag van events


