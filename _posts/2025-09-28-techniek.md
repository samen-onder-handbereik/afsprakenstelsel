---
title: Techniek
author: lg
date: 2025-09-29
category: Jekyll
layout: post
---

Introductie. Binnen de jeugd, zorg en veiligheidsketens willen we flexibel en transparant digitaal samenwerken. Dat lukt met miljoenen burgers en tussen de honderden partners in het sociaal domein alleen als we dat standaardiseren. Daarvoor ontwikkelden we 15 standaard samenwerkfuncties, digitale gereedschappen die iedere partner kan opnemen in zijn eigen casussysteem.

De huidige digitale infrastructuur CORV, de collectieve opdracht routeervoorziening, moeten we verbeteren om die nieuwe samenwerking te ondersteunen. Samenwerken volgens CORV nú werkt als een estafette: van een verzender wordt een opdrachtbericht naar een ontvanger gestuurd, die een resultaatbericht terugstuurt. In die berichten zit veel informatie. De ontvanger bewaart en hergebruikt die informatie.

Nadelen van deze manier van samenwerken zijn:
1. Andere professionals en burgers hebben geen weet van die opdracht of resultaat en ze hebben geen toegang tot de informatie die erin staat
2. De verzender van een bericht kan de kwaliteit en actualiteit van de kopie niet waarborgen
3. De verzender van een bericht heeft geen controle over het gebruik van zijn informatie

Deze nadelen gaan we verhelpen in de volgende versie van CORV: CORV 2.0. We breiden CORV uit met 2 nieuwe gegevensuitwisselingen: Notificeren en Inzien (aanvullend op de bestaande gegevensuitwisseling Opdracht).

Notificeren wordt gebruikt om andere professionals en burgers te laten weten wat er in de samenwerking gebeurt. De aanbieder van een samenwerkfunctie deelt de gebeurtenissen bij iedere verandering. Een ontvanger kan zich daarop abonneren. Zo’n notificatie is informatie-arm: ze bevatten precies genoeg informatie om te bepalen of ze relevant kunnen zijn voor de ontvanger. De notificaties worden gemaakt volgens de standaard ‘CloudEvents’. De voordelen van zo’n notificatie zijn:
1. Doordat je actief wordt geïnformeerd, kun je besluiten te anticiperen op, of parallel te werken met partners
2. Doordat je fijnmazig op de hoogte bent, kun je flexibel reageren in kleine acties
3. Je kunt gericht werken, besluiten wanneer en waarover je contact zoekt en informatie deelt

Inzien betekent dat een aanbieder gegevensdiensten vanuit zijn bron, zijn casussysteem, aanbiedt. Dit kan zowel spontaan als op basis van een Notificatie worden opgevraagd. Inzien verloopt via de Digikoppeling standaard (Digikoppeling Koppelvlakstandaard REST-API). De voordelen van Inzien zijn:
1. De ketenafhankelijkheid vermindert: je kunt op ieder gewenst moment met actuele informatie werken
2. De transparantie en traceerbaarheid van de overheid neemt toe doordat ook historische informatie op termijn betrouwbaar beschikbaar is
3. Zo kunnen alle professionals in het eigen casussysteem werken en tegelijk een virtueel “dossier” inzien, opgebouwd door inzage bij bronnen van anderen.
4. En de burger heeft inzage en kan participeren via een te realiseren burgervoorziening.
5. Hiermee ontstaat een betrouwbaar integraal beeld van de kennis in het netwerk voor wie dat nodig heeft

Dit alles staat of valt natuurlijk met vertrouwen. Daarvoor gaan we in CORV 2.0 de identiteit (wie je bent) en autorisatie (wat je mag) van de afnemer door de aanbieder laten controleren. Daarvoor stappen we naar een schaalbare, beheerbare afsprakenstelsel van toegang verlenen op persoonsniveau. We omarmen daarbij de Europese en Nederlandse toegangsstandaards, voor zowel de burger als voor de professional. Voor de burgers bijvoorbeeld DigiD, eHerkenning en de Wallet. Voor professionals de federatieve toegangsoplossingen van het zorg, gemeentelijk en justitieel domein. En we gaan convenanten en doelbinding vertalen in autorisatieregels.

De voordelen van dit zero trust beveiligingsmodel zijn:
- Geautomatiseerde toegangsverlening wordt mogelijk door vooraf afgesproken autorisatieregels
- Toename van privacy: met informatie bij de bron kan de aanbieder fijnmazig, contextueel en adaptief toegang verlenen
- Je krijgt pas toegang tot Opdrachten, Notificaties en Inzage als je identiteit, bevoegdheid en doelbinding digitaal is aangetoond.

CORV 2.0 vraagt een stevige verandering voor partners en pakketleveranciers. Partners moeten via een nieuw ontkoppelpunt, een API gateway, op CORV 2.0 aansluiten. Op dat ontkoppelpunt zijn de diensten gepubliceerd die je gebruikt, wordt de identiteit en toegang gecontroleerd en de data beschikbaar gesteld. Pakketleveranciers moeten de samenwerkfuncties met Notificaties, Abonnementen en Inzien/Inzage in hun pakket implementeren.

Aanbieders en Afnemers kunnen, op basis van de gestandaardiseerde bouwstenen en uitwisselstandaarden, veel samen af. Vertrekpunt is daarom dat CORV 2.0 federatief en gedecentraliseerd kan werken. Toch voorzien we ook ondersteunende functies in het midden op CORV 2.0 . We denken dan aan:

- Een toegangscatalogus met de identiteit van instanties, professionals en centrale autorisatieregels
- Een dienstencatalogus met een centraal overzicht van beschikbare (data)diensten
- Een Herkomst en Notificatie register: waarin gebeurtenissen worden gelogd
- Tot slot Silvester diensten: tijdelijke diensten die helpen de migratie naar CORV 2.0 te maken

CORV 2.0 (CORV2) wordt zo een gedistribueerde oplossing van API en gebeurtenissen-voorzieningen. Daarmee maken we weer een belangrijke stap naar netwerksamenwerking onder de vingertoppen.

CORV1
-------------

> ##### Concept
{: .block-danger }

CORV (Collectieve Opdracht Routeer Voorziening) verbindt sinds de decentralisaties rond 2015 de gemeentewereld, zorgwereld en justitiewereld om bilateraal berichten te kunnen uitwisselen. Ketenpartners hebben een aansluiting op de CORV via het gemeente, zorg of justitienet. Het betreft een centrale dienst in het zogenoemde hub-spoke model. De routeervoorziening is de centrale hub waar de spokes, lees de verschillende organisaties zijn aangesloten. Via CORV worden berichten tussen organisaties uitgewisseld op basis van asynchroon berichtenverkeer (ebMS). CORV maakt gebruik van een push-push patroon. Dat betekent dat berichten van de melder naar CORV worden geduwd, waarbij CORV vervolgens de berichten ook duwt naar de ontvanger. CORV kent verschillende aanvullende services, naast routeren, denk bijvoorbeeld aan vertalen en monitoring.

De CORV voorziening is gebaseerd op het justitiële service interface (JSI) platform. Dit platform bestaat uit bibliotheken (libraries), componenten, die het realiseren van workflow, translatie en transformatie snel en gestandaardiseerd kunnen. De JSI kent verschillende gestandaardiseerde bouwstenen om service orkestratie, (gegevens)translatie en (protocol)transformatie te realiseren. De JSI componenten zijn gebaseerd op de programmeertaal Python.

CORV ondersteunt het estafette informatie model goed, maar doet dit vooral op basis van een verouderend protocol (ebMS) en een verouderende methodiek ebMS/WUS berichtenuitwisseling. Die veroudering zorgt (op termijn) voor beperkte ondersteuning door leveranciers, minder makkelijk aan te trekken talent dat kennis van heeft van deze techniek, beperkte ondersteuning voor nieuwe wensen en benodigdheden zoals netwerkmodel ondersteuning en ondersteuning van gebeurtenisgedrevenheid. 

Vandaar dat CORV2 ontwikkelt wordt. CORV2 ondersteunt zowel estafette model als netwerkmodel, zowel ebMS als REST API, zowel berichten als vraag-antwoord (REST API) als gebeurtenissen (events). CORV2 zal op termijn geen ebMS/WUS meer ondersteunen. Die termijn zal naar verwachting echter minimaal een decennium zijn. Vandaar dat CORV2 ook een overbruggingsdienst zal bevatten of deze naast CORV2 gepositioneerd zijn. Deze overbruggingsdienst is ook wel bekend onder de naam Silvester. Deze dienst zal berichten conform estafette model kunnen omzetten naar berichten/events conform netwerkmodel en vice versa. Dus ebMS berichten kunnen omzetten naar REST API berichten of events en andersom.

Via het afsprakenstelsel wordt invulling gegeven aan het netwerkmodel. CORV2 is daarbij een, zei het essentieel, hulpmiddel. 

Overwegingen CORV2
-------------

> ##### Concept
{: .block-danger }


### CQRS
CQRS (Command Query Responsibility Segregation) is een architecturaal patroon dat lees- en schrijfoperaties in een systeem scheidt. Het belangrijkste principe is dat methoden die de status van een systeem wijzigen (commands en events) gescheiden worden van methoden die data opvragen (queries).

CQRS is een belangrijke stap in event-gedreven oplossingen om verschillende redenen:
- Het verbetert de schaalbaarheid door lees- en schrijfworkloads onafhankelijk te kunnen schalen.
- Het maakt optimalisatie mogelijk van datamodellen voor specifieke use cases, met aparte schema's voor lezen en schrijven.
- Het vereenvoudigt de integratie met event sourcing, waarbij alle statuswijzigingen als events worden opgeslagen.
- Het ondersteunt betere prestaties en flexibiliteit in complexe domeinen door gespecialiseerde lees- en schrijfmodellen te gebruiken.
- Het verbetert de beveiliging door de toegang tot schrijfoperaties beter te kunnen controleren.

Als een dergelijke CQRS data bron wordt opgenomen in bijvoorbeeld een NoSQL oplossing als graph ontstaan er meerdere voordelen:
- Verbeterde zoekbaarheid: Gegevens zijn eenvoudiger te vinden door geoptimaliseerde opslag en indexering.
- Flexibele datarelaties: Alternatieve dataformaten zoals NoSQL en graph databases maken het leggen en bevragen van complexe relaties tussen gegevens eenvoudiger.
- Snellere query-uitvoering: Geoptimaliseerde indexering zorgt voor efficiënte zoekopdrachten, inclusief mogelijkheden voor full-text zoeken, fuzzy search en geavanceerde zoekfuncties.
- Kunstmatige intelligentie en machine learning: AI en machine learning kunnen patronen en relaties in grote datasets ontdekken, voorspellingen doen over systeemuitval of prestatieknelpunten, en data-gedreven beslissingen ondersteunen.
- Efficiëntere analyse: Het gebruik van flexibele dataformaten vergemakkelijkt het analyseren en verbinden van gegevens, waardoor diepgaandere inzichten mogelijk zijn.

### Ontkoppeling via REST API, ook voor events
Gebruik van een API layer / API Proxy ontkoppelt en voorkomt het implementeren van business logica op een centrale plek (dus in CORV2). Het is een generieke best practice geen business logica op een centrale plek te realiseren en zeker niet  binnen een federatieve omgeving. Door een REST API-koppelvlak te implementeren, creëren organisaties een uniforme interface voor het lezen en schrijven van events. Dit bevordert de consistentie in dataverwerking en vereenvoudigt de integratie met diverse systemen en applicaties. Het API-koppelvlak fungeert als een abstractielaag, waardoor onderliggende complexiteiten van event storage en retrieval worden verborgen voor de consumenten van de API. Veelal gaan we uit van een request / response REST API koppelvlak. Een API kan ook een event koppelvlak bezitten. REST API’s kunnen geïntegreerd zijn in Even Brokers. REST API’s kunnen zcih registeren op webhooks om asynchrone notificaties te ontvangen zodat een polling mechanisme niet nodig is.     

### Graph database
Wanneer een graph database wordt gebruikt als event store, ontstaan er enkele unieke voordelen:
- Rijke relaties: Graph databases kunnen complexe relaties tussen events en entiteiten efficiënt modelleren en bevragen.
- Flexibele queries: Het maakt geavanceerde traversals en patroonherkenning mogelijk tussen gerelateerde events.
- Schaalbaarheid: Graph databases presteren goed bij het verwerken van grote hoeveelheden onderling verbonden data.
- Contextbehoud: De graph-structuur helpt bij het behouden van de context rond events.

CORV2 is daarom gebaat bij de toepassing van graph database als event store.

### Data lineage / Data provenance
Data lineage of data provenance is het vastleggen van de volledige levenscyclus van gegevens, van hun oorsprong tot hun huidige staat, en het is belangrijk om verschillende redenen. Ten eerste helpt het bij het verifiëren van de datakwaliteit en betrouwbaarheid door een duidelijke geschiedenis van transformaties te bieden. Daarnaast maakt het de dataverwerking transparant en houdt het gegevensverwerkers verantwoordelijk voor hun acties, wat bijdraagt aan de integriteit van gegevens.

Bovendien ondersteunt data lineage organisaties bij het voldoen aan wettelijke en industriële standaarden door de nauwkeurigheid en legitimiteit van gegevens te waarborgen. Het stelt ontwikkelaars en data-analisten ook in staat om de oorsprong en transformatie van gegevens te traceren, waardoor fouten efficiënt kunnen worden opgespoord en gecorrigeerd. Dit proces helpt verder bij het opbouwen van vertrouwen in de gegevens door de herkomst en authenticiteit ervan te bevestigen. Tot slot bevordert data lineage de reproduceerbaarheid van onderzoeksresultaten door een gedetailleerde trail van gegevensbewerkingen te bieden. Hierdoor kunnen organisaties de integriteit van hun gegevens waarborgen, besluitvorming ondersteunen en voldoen aan steeds strengere eisen op het gebied van gegevensbeheer en privacy.

Event stores passen goed bij data lineage of data provenance om verschillende redenen:
- Chronologische vastlegging: Event stores leggen gebeurtenissen chronologisch vast, wat perfect aansluit bij het traceren van de herkomst en transformatie van data over tijd.
- Onveranderlijke geschiedenis: Events worden opgeslagen in een onveranderlijk formaat, waardoor een betrouwbare en volledige historische weergave van alle datawijzigingen behouden blijft.
- Gedetailleerde tracking: Elke datawijziging wordt als een afzonderlijk event opgeslagen, wat een zeer gedetailleerd inzicht geeft in hoe data is getransformeerd en verplaatst.
- Reconstructie van toestanden: Door events sequentieel af te spelen, kan de toestand van data op elk willekeurig moment in de geschiedenis worden gereconstrueerd.
- Foutcorrectie en audittrail: Event stores bieden mechanismen voor foutcorrectie zonder de originele events te wijzigen, wat cruciaal is voor nauwkeurige data lineage.
- Flexibiliteit in analyse: De eventgebaseerde structuur maakt het gemakkelijk om complexe queries uit te voeren en datastromen te analyseren, wat essentieel is voor data provenance.

### Event Datamodel
Het is essentieel dat er een gestandaardiseerd keten Event Datamodel toegepast wordt en dat model wordt beheerd. Standaardisatie van het event data model biedt verschillende voordelen voor organisaties die event sourcing toepassen.

Ten eerste zorgt een gestandaardiseerd event datamodel voor consistentie en interoperabiliteit binnen en tussen systemen. Dit maakt het gemakkelijker om events uit te wisselen, te verwerken en te interpreteren, ongeacht waar ze zijn gegenereerd of worden gebruikt. Standaardisatie bevordert ook de schaalbaarheid en flexibiliteit van event-gebaseerde systemen, omdat nieuwe componenten of diensten eenvoudiger kunnen worden geïntegreerd wanneer ze een gemeenschappelijk datamodel volgen.

Daarnaast is het juiste beheer van het event data model cruciaal voor de langetermijnwaarde en bruikbaarheid van de opgeslagen events. Events zijn immers de onveranderlijke feiten die de basis vormen van het systeem. Een goed beheerd datamodel zorgt ervoor dat events begrijpelijk en bruikbaar blijven, zelfs als de systemen en processen eromheen evolueren. Dit is vooral belangrijk omdat events vaak worden gebruikt om de volledige geschiedenis van een systeem te reconstrueren of om complexe analyses uit te voeren.

Het beheer van het event data model moet rekening houden met de dynamische aard van bedrijfsprocessen en datarelaties. Entiteiten en hun relaties kunnen veranderen over tijd, en het datamodel moet flexibel genoeg zijn om deze veranderingen te accommoderen zonder de integriteit van historische data te compromitteren. Dit vereist een zorgvuldige aanpak van datamanagement, waarbij veranderingen in het model worden gedocumenteerd en backward compatibility wordt gewaarborgd.

Door een gestandaardiseerd en goed beheerd event data model te hanteren, kunnen organisaties de volle potentie van event sourcing benutten. Het stelt hen in staat om betrouwbare audit trails te maintainen, complexe analyses uit te voeren, en systemen te bouwen die robuust en aanpasbaar zijn aan veranderende zakelijke behoeften.


Gebeurtenissen (events)
-------------

![Alt text]({{ site.baseurl }}/assets/eventshl.png)

> ##### Concept
{: .block-danger }

### Identificeren en uitsturen van gebeurtenissen
Binnen het stelsel willen we gebeurtenissen kunnen delen. Bijvoorbeeld: “Wij Politie hebben zojuist melding xyz gedaan bij Veilig Thuis”. Een eerste vraag is dan hoe we gebeurtenissen kunnen identificeren en uitsturen vanuit de bron, lees het systeem dat de desbetreffende partij gebruikt. Hier zijn grosso modo de volgende mogelijke manieren voor:
1. Het (business/zaak)systeem ondersteunt native het genereren en uitsturen van events.
2. Het (business/zaak)systeem ondersteunt eventcreatie en verzending nog niet, maar dit kan in het systeem worden ingebouwd.
3. Het (business/zaak)systeem ondersteunt eventcreatie en verzending niet, maar met ‘External Event Capture’ functionaliteit kunnen alsnog events worden gegenereerd en uitgestuurd.

Denk bij dit laatste aan het monitoren van applicatie logging (log scraping), database triggers/capture (CDC) of automation hooks (RPA of automation tool). Zodoende kunnen events worden geïdentificeerd, geëxporteerd, onderschept of gesynthetiseerd en vervolgens worden uitgestuurd.


> ##### Concept
{: .block-danger }

### Gebeurtenissen vormgeven en verzenden
Een gebeurtenis wordt vormgeven binnen de CloudEvents standaard en conform het NL GOV profile for CloudEvents. De daadwerkelijke inhoud is afgeleid van het betreffende informatiemodel van de betreffende samenwerkfunctie (zie Samenwerkfuncties). Objecten en attributen volgen waar afgesproken de definities van het Begrippenkader.

De gebeurtenis wordt verzonden naar de CORV2 event broker. Deze biedt hiervoor een REST API aan (REST API Proxy naar Event Platform event-log/topic). De REST API wordt aangeroepen en het event via deze API aangeleverd. De REST API is beschreven in het API Management DevPortal van CORV2.



> ##### Concept
{: .block-danger }

### Gebeurtenissen ontvangen en interpreteren
De organisatie welke gebeurtenissen wil of moet ontvangen, heeft het ontvangen daarvan in eigen hand. De organisatie kan via de betreffende REST API (REST API Proxy naar Event Platform event-log/topic) een ‘pull’ actie uitvoeren en zodoende (relevante) gebeurtenissen ophalen.

Uiteraard is toegang nodig tot deze REST API en de gebeurtenissen. Wat betreft gebeurtenissen zijn hier twee varianten:
1. De betreffende gebeurtenissen zijn voor de gehele keten toegankelijk. Merk op dat de gebeurtenis (het event) weinig informatie bevat en er een inzage verzoek nodig is voor meer informatie.
2. De betreffende gebeurtenissen zijn alleen toegankelijk voor partijen die een toegangsverzoek hebben gedaan, dat is gehonoreerd. Zij ontvangen dan een token waarmee de gebeurtenissen toegankelijk worden. Ook hier zal doorgaans een inzage verzoek nodig zijn voor meer informatie.    

Het genoemde inzage verzoek kent een eigen toegangsverleningsproces (authenticatie/autorisatie).

Interpretatie van gebeurtenissen wordt gefaciliteerd door enerzijds de CloudEvent standaard. De REST API response bevat de in de CloudEvents standaard en conform het NL GOV profile for CloudEvents vormgegeven event. Anderzijds door event informatiemodel. Dit gaat over wat in het Cloud Event wordt geplaatst (welke attributen/headers). Dit is ook wel bekend onder de noemer Schema registry pattern. Een Schema registry levert versioning en backward and forward compatibility. Verder wordt de interpretatie gefaciliteerd door het informatiemodel en daarmee ook door de definitie van objecten en attributen conform het keten Begrippenkader en door de samenwerkfunctie (zie Samenwerkfuncties).



> ##### Concept
{: .block-danger }

### Gebeurtenissen verwerken
Ontvangen en (kunnen) interpreteren is niet voldoende. Gebeurtenissen moeten kunnen worden verwerkt in het (business/zaak)systeem. Hier zijn grosso modo de volgende mogelijke manieren voor:
1. Het (business/zaak)systeem ondersteunt native events subscription en verwerking. Het systeem kan de events verwerken, ‘parsen’ en acties nemen op basis van de inhoud van de events.
2. Het (business/zaak)systeem ondersteunt events subscription en verwerking nog niet, maar dit kan in het systeem worden ingebouwd.
3. Het (business/zaak)systeem ondersteunt eventcreatie en verzending niet, maar met ‘middleware services’ kunnen de events alsnog worden verwerkt en acties uitgezet worden, bijvoorbeeld door transformatie naar systeem API calls, system calls, database mutaties of UI automation acties.

Onderdeel van de verwerking van gebeurtenissen is het analyseren daarvan via bijvoorbeeld business rules of workflow engines. Op basis van de analyse kunnen acties worden uitgezet (binnen het systeem / de applicatie). Dit kan binnen de applicatie zelf of binnen daarvoor bestemde (middleware) services.

### Gebeurtenissen routeren
Binnen het stelsel moeten gebeurtenissen tussen verschillende organisaties uitgewisseld kunnen worden. Technisch bezien zou dat direct kunnen, dus zonder centrale of gedeelde voorzieningen. In praktische zin echter niet gelet onder andere  complexiteit en schaalbaarheid. Er is voor de uitwisseling van gebeurtenissen dus een gedeelde voorziening nodig (CORV2).

De uitwisseling en routering van de gebeurtenissen kan in een publish/subscribe (pub/sub)model. Doorgaans wordt hiervoor gekozen wanneer sprake is van gelijksoortige omgevingen en daardoor ook native pub/sub interfaces gebruikt kunnen worden, of wanneer het aantal organisaties waarmee wordt uitgewisseld beperkt is. In dit geval is van geen van beide sprake. Vandaar dat gekozen wordt voor een benadering in hogere mate loosely coupled is dan pub/sub. Die benadering maakt gebruik van REST API interfaces die voor de logg/stream/topic interfaces geplaatst worden en van het push/pull model (in plaats van pub/sub). Organisaties (event producers) sturen gebeurtenissen via een gedefinieerde standaard REST API naar de Event Hub (CORV2), ontvangende organisaties (consumers) bevragen (pull) de Event Hub op nieuwe berichten.


Bevragingen en opdrachten (REST API)
-------------

![Alt text]({{ site.baseurl }}/assets/apihl.png)

> ##### Concept
{: .block-danger }

### Identificeren en uitsturen van vraag of opdracht
Binnen het stelsel moet informatie opgevraagd kunnen worden of opdrachten uitgezet. Ook kan sprake zijn dat informatie moet worden gewijzigd of verwijderd. Meer technisch geformuleerd zouden we kunnen spreken over CRUD. CRUD staat voor Create, Read, Update en Delete. REST API’s zijn zeer geschikt voor dit type operaties. Op basis van het Keteninformatiemodel, het Begrippenmodel en Samenwerkingsfuncties en Samenwerkpatronen kunnen vragen of opdrachten worden samengesteld in de vorm van REST-API calls.

Als reeds bekend is welke REST-API we nodig hebben kan deze worden aangeroepen. Als dit nog niet het geval is kan deze worden opgezocht door de API Catalog te raadplegen.

De REST API’s calls kunnen direct vanuit het (zaak)systeem/applicatie worden gedaan of kunnen specifieke (micro)services worden ingezet.


> ##### Concept
{: .block-danger }

### Vragen/opdrachten vormgeven en verzenden
De verwerking van de ontvangen response vindt plaats in het (zaak)systeem/applicatie of daaraan gerelateerde specifieke (micro)services.

> ##### Concept
{: .block-danger }

### Vragen/opdrachten verwerken
Aanbieders van de REST-API publiceren deze in hun API DevPortal. Daar is in meer detail na te gaan hoe de API calls vormgegeven dienen te worden, hoe toegang kan worden aangevraagd etc. Verder helpen het Keteninformatiemodel, het Begrippenmodel en Samenwerkingsfuncties en Samenwerkpatronen bij de vormgeving van de calls. Andersom helpen deze ook hoe de REST API’s door de aanbieder ervan gebouwd en aangeboden dienen te worden.


> ##### Concept
{: .block-danger }

### Typen REST-API’s
Enerzijds zullen er wat resources-API’s genoemd worden zijn. Deze volgen de interne / domeinspecifieke resources met overeenkomstige duidelijke, consistente, zelfstandige naamwoorden (nouns) conform de API design rules. Deze zullen doorgaans worden geabstraheerd achter wat we keten-API’s noemen. Die volgen het afgesproken Keteninformatiemodel en het Begrippenkader en daarmee niet noodzakelijkerwijs de achterliggende resource benamingen (binnen het systeem/applicatie en het informatiemodel daarvan). Deze keten-API’s kunnen meerdere achterliggende resources-API’s benaderen om bijvoorbeeld het aantal API call’s te reduceren. De keten-API’s kunnen ook achterliggende business-API’s benaderen. Een business API richt zich op bredere bedrijfsprocessen of business capabilities als resource. In plaats van data-objecten op een lager niveau richt een business API zich op functionele eenheden die een businessdoel dienen. Dat in tegenstelling tot een resource-API welke is gebouwd rondom het concept van resources en daarmee van data entiteiten of objecten die via unieke URI's worden geïdentificeerd.


> ##### Concept
{: .block-danger }

### Combinatie (zoals inzage na gebeurtenis)

Binnen de Samenwerkfuncties zal nadrukkelijk ook een combinatie worden gebruikt. Een organisatie kan een notificatie doen (event uitsturen), andere organisaties kunnen op basis van het event een bevraging doen (REST-API).

Deze werkwijze heeft als bijkomstig voordeel dat REST API authenticatie en autorisatie hergebruikt kan worden. Daardoor kan de complexiteit van het  toegangslandschap worden gereduceerd.

Werking CORV2
-------------

> ##### Concept
{: .block-danger }

De werking van CORV2 is in meer detail hieronder uitgebeeld en beschreven.

![Alt text]({{ site.baseurl }}/assets/corv2funct.png)

Stappen:
1. Aanvragen van een autorisatie token voor event-log/topic (alleen voor gesloten topics)
2. Opvragen van het schema
3. Aanleveren van events (push)
4. Opvraag events insturen (pull initiatie), response bevat request-id
5. Opvragen event (pull) aan de hand van het request-id

CORV2 componenten:
- **Schema registry** – Opslag van event data schema’s t.b.v. versioning, backward/forward compatibility, validatie en voorkomen van breaking changes
- **REST API (Proxy)** – Transformatie van event streams naar REST API voor ontkoppeling en abstractie
- **Event broker** – Ontvangen, routeren en doorgeven van events
- **House keeping service** – Opschonen, retentie van event logs/topics
- **Writer services** – Database en Blockchain writers voor (immutable en onweerlegbare) opslag van events

Er wordt hiermee een asynchrone benadering gevolgd. Organisaties sturen events naar CORV2 (push), andere organisaties halen deze daar op (pull). De ‘pull’ vindt in twee stappen plaats (4 en 5 in de figuur). In de eerste stap geeft een organisatie aan in welke events deze organisatie interesse heeft. CORV geeft een request-id terug en gaat een query definiëren aan de hand van het verzoek. De organisatie vraagt met het request-id in een tweede stap of de events beschikbaar zijn. Als dat het geval is stuurt CORV2 het event of de events terug op basis van de query en het request-id. Deze benadering zorgt voor schaalbaarheid en performance.

CORV2 slaat events op om de asynchrone bevraging daarvan mogelijk te maken. Primair slaat CORV2 de events echter op om een ketenindex van gebeurtenissen mogelijk te maken. Daarmee kunnen bijvoorbeeld gebeurtenistijdslijnen zichtbaar worden gemaakt. Bij de opslag wordt gezorgd dat verbanden tussen events kunnen worden gelegd , de events onveranderlijk zijn (immutable/ append only) en onweerlegbaar, maar ook dat events vindbaar en te ‘queryen’ zijn. Hiervoor worden verschillende technologieën toegepast: provenance, block chain en graph.

Provenance:  
W3C Provenance (PROV) is een standaard die beschrijft hoe je de herkomst, geschiedenis en afleiding van data kunt vastleggen en uitwisselen. Het draait om het modelleren van wie, wat, wanneer en hoe data is ontstaan of veranderd.

Provenance betekent letterlijk "herkomst". In de context van data en W3C PROV gaat het om informatie over:
- Entiteiten: de data of objecten zelf.
- Activiteiten: processen of handelingen die data creëren, wijzigen of gebruiken.
- Agenten: personen, organisaties of systemen die verantwoordelijk zijn voor activiteiten.

Naast deze kernelementen kent PROV-DM (het PROV Data Model) relaties:
- wasGeneratedBy: een entity is voortgebracht door een activiteit.
- wasDerivedFrom: een entity is afgeleid van een andere.
- wasAttributedTo: een entity is toegeschreven aan een agent.
- used: een activiteit gebruikte een entity.
- wasAssociatedWith: een activiteit werd uitgevoerd door een agent.

De provenance-informatie helpt bij het beoordelen van de betrouwbaarheid, kwaliteit, verantwoordelijkheid en herleidbaarheid van data.

Provenance wordt gebruikt om events in PROV-DM formaat op te slaan en relaties (een ketting van events) te kunnen makenDit gaat om het command deel van CQRS (zie eerdere toelichting CQRS). Voor het query deel wordt graph toegepast (zie verderop)

Block chain:  
Blockchain is een gedecentraliseerde digitale technologie waarmee gegevens veilig, transparant en onveranderlijk worden opgeslagen in blokken die met elkaar verbonden zijn in een keten. Hiermee wordt invulling geven aan de immutable-,  append only- en onweerlegbaarheidsaspecten.

Graph:  
Een graph database is een type database waar gegevens opgeslagen kunnen worden in de vorm van knooppunten (nodes) en relaties (edges), waardoor complexe verbanden tussen data efficiënt en intuïtief kunnen worden gemodelleerd en geanalyseerd. De Graph wordt toegepast om events bevraagbaar te maken, of wel voor het query deel van CQRS.

Koppelvlakken
-------------

> ##### Concept
{: .block-danger }

De asynchrone koppelvlakken van CORV2 zijn REST-API koppelvlakken i.v.m. ontkoppeling en hergebruik van de authenticatie en autorisatie aanpak en voorzieningen bij REST-API. 

Event worden beschreven conform CloudEvents en het NL GOV profile for CloudEvents. De API’s worden beschreven conform AsyncAPI

CloudEvents beschrijft de minimale, gestandaardiseerde event‑envelope: welke contextvelden (specversion, id, source, type, datacontenttype, dataschema, extensions) er zijn en hoe die seraliseert in binary of structured mode. 

AsyncAPI is het OpenAPI‑achtige model voor asynchrone APIs: het beschrijft servers/brokers, channels (topics), berichten, operationele bindingen en payload‑schema’s; het dwingt de vorm van je API‑contract af en ondersteunt tooling zoals documentatie en codegeneratie.

| Attribuut             | CloudEvents                                                      | AsyncAPI                                                        | Combinatie                                                                                             |
|-----------------------|-----------------------------------------------------------------|----------------------------------------------------------------|------------------------------------------------------------------------------------------------------|
| Scope                 | Standaard voor event‑envelope / metadata                        | Specificatie voor volledige async API (channels, messages, servers) | Gebruik CloudEvents voor berichten; AsyncAPI voor documentatie van kanalen en contracten              |
| Hoofddoel             | Interoperabele event‑beschrijving                               | Ontwerp, documentatie en tooling voor messaging APIs           | Documenteer CloudEvents‑gebaseerde events in AsyncAPI                                                |
| Format / binding      | Definieert contextvelden en serialisatie modes (binary/structured) | Beschrijft channels, bindings (Kafka, AMQP, HTTP) en berichtschema’s | Map CloudEvents velden naar bindings die AsyncAPI beschrijft                                        |
| Schema en validatie   | Verwijst naar dataschema (dataschema veld) maar specificeert geen payload‑DSL | Ondersteunt JSON Schema / Avro etc. voor payloads en genereert code/validators | Gebruik AsyncAPI om het payload‑schema (zoals JSON Schema) te hosten en te valideren.                 |
| Tooling               | Geen                                                            | Tooling voor docs, codegen, mock servers en contract testing   | Gebruik AsyncAPI tooling voor docs en contracttests en optioneel voor Event Catalog / DevPortal.     |




Toegang
-------------

> ##### Concept
{: .block-danger }

Zowel bij gebeurtenissen als bij vraag- en antwoord patronen kan informatie pas worden gezien of geraadpleegd als er daartoe toegang is. De ontvangende of vragende partij zal zich moeten authentiseren (bewijzen wie je bent) en moeten worden geautoriseerd (toegangsrechten ontvangen) voor toegang. 

In voorliggende context gaat het vooral om toegangsverlening door de ene organisatie aan een andere organisatie. Binnen samenwerkingsverbanden/ketens wordt hierbij vrijwel altijd het concept van federatieve toegangsverlening toegepast. Federatieve toegangsverlening  is een manier om op een veilige en gecontroleerde wijze toegang te regelen tot gegevens en systemen, waarbij meerdere organisaties samenwerken op basis van onderling vertrouwen.

Er zijn verschillende manieren van toegangsverlening:
In toegangsverlening tussen overheden:
- Organisatie identificatie(nummer) en certificaat
- Persoon + Organisatie en rol (RBAC)
- Persoon + Attributen/claims/policies (ABAC/CBAC/PBAC)

Bij toegangsverlening van bedrijven, intermediairs, eenmanszaken, stichtingen, etc.  naar overheid of dienstaanbieders:
- eHerkenning - eHerkenning is een persoonsgebonden zakelijk inlogmiddel waarmee gebruikers namens hun organisatie veilig kunnen inloggen bij verschillende (overheids)diensten, zoals gemeenten, ministeries, verzekeraars en pensioenfondsen.

Bij toegangsverlening van burger naar overheid of dienstaanbieders
- eIDAS (DigiD – het Nederlandse nationale inlogmiddel dat is aangesloten op eIDAS)
- Self Sovereign Identitity attributen

Binnen federatieve toegangsverlening speelt vertrouwen een rol. Denk aan vertrouwen in verordeningen als eIDAS en hun implementatie, vertrouwen in de sterkte van inlogmiddelen, vertrouwen in claims en attributen zoals deze door een organisatie worden aangeleverd etc.

### OIN en certificaat
Een veel toegepaste toegangsverlening bij system2system gegevensuitwisseling is op basis van Organisatie identifier (Organisatie-Identificatienummer (OIN)) en (PKI-Overheid)certificaat. Dit is dan ook wat we in het stelsel in eerste instantie zullen gaan toepassen. Een organisatie krijgt toegang op basis van OIN en certificaat en worden afspraken gemaakt wie toegang kan en mag krijgen. De aanvragende partij regelt deze toegang in en de leverende partij vertrouwd op de gemaakte afspraken en implementatie daarvan. Tussen beide partijen wordt een beveiligd en versleuteld communicatie opgezet op basis van de OIN’s en certificaten. Wat betreft certificaten is het gebruik van PKI-Overheid certificaten binnen het stelsel verplicht.

### OIN en certificaat FSC variant
FSC is een standaard die beschrijft hoe (overheids)organisaties op een gestandaardiseerde, veilige en schaalbare manier gegevens met elkaar kunnen uitwisselen zonder afhankelijk te zijn van een centrale partij. FSC werkt op een zelfde manier als hiervoor beschreven bij OIN en certificaat maar belooft schaalbaarheid, en bevat mogelijkheden om afspraken (contracten) gedigitaliseerd te kunnen maken. Verder is FSC een voorgeschreven standaard (zie Forum Standaardisatie). FSC is een betrekkelijk nieuwe standaard. Zo zijn er eind 2025 nog weinig tot geen productionele inter-organisatie implementaties. De standaard wordt eind 2025 nog niet ondersteund door leveranciers. Wel is er een Open Source software implementatie beschikbaar (OpenFSC) waarmee organisatie kunnen testen. De verwachting is dat FSC gebruik in de toekomst zal groeien. Binnen het stelsel willen we FSC dan ook gaan ondersteunen en afhankelijk van de ontwikkelingen daar mogelijk volledig op over gaan in de toekomst.

### Persoon + Organisatie en rol
In plaats van organisatie kan ook toegang worden verleend op basis van persoon, organisatie en rol (RBAC). RBAC kan in de praktijk leiden tot een explosie van rollen. De toepassing van RBAC kan een tussenstap zijn naar Attributen/claims/policies gebaseerde toegang. RBAC kan worden gestapeld op OIN en certificaat gebaseerde toegang.

Een groot aantal rijksoverheid partijen waaronder JenV hebben een federatief stelsel waarin de verschillende gebruikersregistraties worden ontsloten via het SAML en OIDC/OAuth protocol. Personen in deze registraties kunnen op deze wijze geauthentiseerd worden. Personen kunnen inloggen met verschillende middelen en die middelen kunnen van verschillende sterkte zijn (denk aan password vs authenticator-app vs hardtoken). Er is dus ook verschil in betrouwbaarheidsniveau’s of wel Level of assurance (LOA). Zie in dit kader bijvoorbeeld het JenV Trustframework.

### Attributen/claims/policies
Een andere benadering rond toegangsverlening is toegangsverlening op basis van attributen/claims/policies. De toegang vragende partij levert attributen/claims aan zoals wie het is die toegang wil, en bijvoorbeeld van welke organisatie deze persoon is, welke rol deze persoon heeft, aan welk dossier de toegangsaanvraag gelieerd is. De toegang verlenende partij beslist op basis van deze attributen/claims of de toegang verstrekt wordt. De toegang verlenende partij kan dat doen op basis van vooraf gedefinieerde policies. Dit type toegang is te stapelen op OIN en certificaat gebaseerde toegang. Binnen het stelsel willen we zoveel mogelijk naar deze manier van toegangsverlening bewegen. Ook hier geldt dat federatiebe stelsels en bijbehorende gebruikersregistraties kunnen worden gebruikt voor de toegangsverlening (zie beschrijving bij Persoon + Organisatie en rol).    

### Attributen/claims/policies FTV variant
Zoals FSC een variant is op het industriewijde mutual tls toegangsconcept (OIN/Certificaat benadering) en inmiddels een standaard. Zo wordt er ook gewerkt aan de FTV standaard als variant op het industriewijde ABAC/PBAC toegangsconcept en eveneens als standaard. FTV staat voor Federatieve Toegangsverlening. Het is een moderne standaard en methodiek om toegangsbeheer binnen het federatieve datastelsel (FDS) te organiseren. Aan FTV wordt eind 2025 nog gewerkt en de ontwikkeling zal tot in 2026 en mogelijk verder doorlopen. Ook FTV is te stapelen op FSC. De verwachting is dat FTV gebruik in de toekomst zal groeien. Binnen het stelsel willen we FTV dan ook gaan ondersteunen en afhankelijk van de ontwikkelingen daar mogelijk volledig op over gaan in de toekomst.

FTV gebruikt AuthZEN als basisstandaard voor toegangsbeheer. AuthZEN is een open standaard binnen de OpenID Foundation die de interface standaardiseert tussen het Policy Enforcement Point (PEP) en het Policy Decision Point (PDP), wat essentieel is voor externalized authorization management. Het bevat een informatiemodel en APIs om toegangsbeslissingen real-time te maken op basis van wie toegang vraagt, wat wordt gevraagd, en in welke context dit plaatsvindt. FTV bouwt voort op AuthZEN voor het centraal beheren van toegangsregels en het maken van toegangsbeslissingen, waardoor toegang tot gegevens en diensten flexibel en veilig kan worden geregeld binnen federatieve omgevingen.

### eHerkenning
eHerkenning is met name bedoeld voor toegang van bedrijven, intermediairs, eenmanszaken, stichtingen, etc. naar overheden en dienstaanbieders. Als hier binnen het stelsel sprake van is of gaat worden, dan zal eHerkenning voor deze toegangsverlening worden toegepast.

DigiD en eHerkenning ondersteunen de SAML standaard. Voor de toekomst is de verwachting dat DigiD/eHerkenning ook de OpenID Connect en OAuth standaard zullen ondersteunen. Daar zullen we dan naar overstappen. Verder zal een (medewerker van) een bedrijf zich in de toekomst met een Wallet kunnen identificeren.

### eIDAS /DigiD
eIDAS en DigiD zijn bedoeld voor digitale toegangsverlening waarbij de gebruiker zich online identificeert en authentiseert om toegang te krijgen tot digitale diensten van de overheid en organisaties met een publieke taak. Als hier binnen het stelsel sprake van is of gaat worden, dan zal eIDAS /DigiD voor deze toegangsverlening worden toegepast.

DigiD en eHerkenning ondersteunen de SAML standaard. Voor de toekomst is de verwachting dat DigiD/eHerkenning ook de OpenID Connect en OAuth standaard zullen ondersteunen. Daar zullen we dan naar overstappen. Verder zal een burger zich in de toekomst met een Wallet kunnen identificeren, zie Self Sovereign Identitity.

### Self Sovereign Identitity
Dit is een visie op identiteiten waarbij de gebruiker zelf centraal staat. De identiteit attributen zijn dan niet gebonden aan een specifieke partij of site. Ze zijn en blijven van en onder controle van de gebruiker. De gebruiker kan de eigen identiteit voorzien van allerlei verklaringen die deels van henzelf komen (bijv. email adres) en deels van andere partijen. Gebruikers bepalen zelf aan wie ze de verklaringen en gegevens verstrekken en er worden geen gegevens verstrekt die niet nodig zijn.  
Deze visie is terug te vinden in een aantal Wallet (apps).

Policy-Based Access Control
-------------

> ##### Concept
{: .block-danger }

Binnen het afsprakenstelsel wordt gebruik voor gegevensraadpleging gebruik  gemaakt van authenticatie, autorisatie en in een federatief model policy based model. De kern van het PBAC stelsel wordt beheerd door Vertrouwensleverancier en maakt gebruik van open-source componenten, waaronder Open Policy Agent (OPA).

Het PBAC stelsel bestaat uit de volgende onderdelen:

- **Policy Enforcement Point (PEP)**  
  Voert het toegangsbesluit uit. Het controleert of een gebruiker toegang krijgt en handhaaft het besluit (toestaan of weigeren).
- **Policy Decision Point (PDP)**  
  Neemt het toegangsbesluit. Het evalueert de beleidsregels op basis van de aanvraag en informatie van andere punten.
- **Policy Retrieval Point (PRP)**  
  Slaat de beleidsregels op en levert ze aan de PDP wanneer die een besluit moet nemen.
- **Policy Administration Point (PAP)**  
  Beheert en definieert de beleidsregels. Dit is de plek waar beheerders beleid aanmaken, wijzigen of verwijderen.
- **Policy Information Point (PIP)**  
  Verzamelt extra contextuele informatie (zoals gebruikersattributen of omgevingsgegevens) die nodig is voor de PDP om een besluit te nemen.

Tevens uit:

- **Autorisatieserver**  
  Verantwoordelijk voor het uitgeven en beheren van toegangsrechten (zoals tokens). Ze controleert de identiteit van gebruikers en bepaalt op basis van beleid of en welke toegang wordt verleend.
- **Resource-server**  
  Bevat de beschermde gegevens of diensten en verleent alleen toegang als de gebruiker een geldig toegangs- of autorisatietoken kan tonen, uitgegeven door de autorisatieserver.

De **Audience** (doelgroep of ontvanger) is de partij waarvoor het access token bedoeld is — meestal de resource-server.

Er zijn verschillende inrichtingen mogelijk zoals volledige decentrale inrichting, een centrale inrichting en een hybride inrichting. Er worden beproevingen gedaan op dit vlak, voor nu wordt uitgegaan van een inrichting zoals hieronder beschreven. De kern daarvan is: **decentrale uitvoering en beslissen, centrale kaders en vertrouwen**.

Decentrale componenten bij de organisaties zelf:

- Vanzelfsprekend de Resource-server en PEP voor toepassen van de policies (verantwoordelijkheid) Bronhouder
- PDP, bij de resource-eigenaar voor autonome beslissingen; kan centrale regels inladen
- PIP, lokale bronattributen blijven bij de organisatie; er kan sprake zijn van externe en centrale bronattributen
- PAP, voor het definiëren van de lokale beleidsregels
- Autorisatieserver, verifieert identiteiten en levert claims/tokens, maakt onderdeel uit van toegangsfederatie en kan verifiëren bij Identity Providers (IDP’s) van andere organisaties (via IDP-broker).

Gemeenschappelijke delen welke organisaties zelf kunnen toepassen, maar elkaar daar wel voor nodig hebben:
- Toepassing van PKIoverheid voor de benodigde PKI-infrastructuur
- Toepassing FSC voor mutual TLS verbindingen op basis van contracten (potentieel gebruik van FDS FSC-directory en catalog)

Centrale delen en informatie/beheer toegang gerelateerde afspraken (beide geleverd door de Vertrouwensleverancier):
- Afspraken t.a.v. PKIoverheid, FSC
- Attribute-/claim-normalisatie mapping/normalisatie van attributen (schemas/entitlements) zodat claims van verschillende organisaties consistent zijn
- PAP ketenvoorziening t.b.v. gezamenlijke normen, -taxonomie (namen van attributen/rollen) en “baseline policies”
- PRP ketenvoorziening, t.b.v. verspreiding van centrale/baseline policies en gemeenschappelijke modules
- Federation broker, voor token brokering (audience scoping, token exchange)

Deze inrichting levert op:
- Autonomie & performance: handhaving (PEP) en beslissen (PDP) dicht bij de resource.
- Consistentie & vertrouwen: policy-kaders, attributenschema en sleutels centraal.
- Privacy by design: attributen blijven waar ze ontstaan; alleen noodzakelijke, genormaliseerde claims delen.
- Schaalbaarheid: elke organisatie beheert eigen policies/identiteiten, terwijl de federatie het “spelregelboek” en de trust laag levert.





